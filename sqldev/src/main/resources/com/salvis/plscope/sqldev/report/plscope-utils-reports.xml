<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[plscope-utils Reports]]></name>
	<tooltip><![CDATA[PL/Scope reports]]></tooltip>
	<description><![CDATA[PL/Scope reports provided by plscope-utils, see https://github.com/PhilippSalvisberg/plscope-utils ]]></description>
		<display id="1dc49f53-015d-1000-8001-c0a8011251fe" type="" style="Table" enable="true">
		<name><![CDATA[Duplicate SQL Statements]]></name>
		<description><![CDATA[Reports duplicate static SQL statements within packages, procedures, functions, triggers and types. ]]></description>
		<tooltip><![CDATA[Reports duplicate static SQL statements]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[WITH
   stmt AS (
      SELECT owner,
             object_type,
             object_name,
             type,
             line, 
             col, 
             sql_id,
             CASE 
                WHEN (count(sql_id) OVER (PARTITION BY sql_id)) > 1 THEN 
                   'YES'
                ELSE 
                   'NO' 
             END AS is_duplicate,
             full_text
        FROM sys.all_statements
       WHERE owner LIKE nvl(:OBJECT_OWNER, USER)
   )
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(line,'FM0000009') || ':' || to_char(col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       owner AS "Owner",
       object_type AS "Object type",
       object_name AS "Object name",
       type AS "Type",
       line AS "Line", 
       col AS "Col", 
       sql_id AS "SQL_ID",
       full_text AS "Text"
  FROM stmt
 WHERE is_duplicate = 'YES'
 ORDER BY owner, object_type, object_name, sql_id, line, col]]></sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					
					null															</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="27802dea-015d-1000-8001-c0a80106a1a4" type="" style="Table" enable="true">
		<name><![CDATA[UDF Calls in SQL Statements]]></name>
		<description><![CDATA[Reports static SELECT, INSERT, UPDATE, DELETE and MERGE statements within packages, procedures, functions, triggers and types using user-defined function calls.]]></description>
		<tooltip><![CDATA[Reports user-defined function calls in SQL statements]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[WITH
   base_ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
      UNION ALL
      SELECT owner,
             ':' || NVL(sql_id, type) AS name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' AS usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
       FROM sys.all_statements
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             coalesce(
                least(
                   usage_context_id,
                   max(usage_id) over (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY usage_id
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
                ),
                0
             ) AS usage_context_id -- fix broken hierarchies
        FROM base_ids
       WHERE owner LIKE nvl(:OBJECT_OWNER, USER)
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   ),
   plscope_identifiers AS (
      SELECT tree.owner,
           tree.object_type,
           tree.object_name,
           tree.line,
           tree.col,
           last_value (
              CASE
                 WHEN tree.type in ('PROCEDURE', 'FUNCTION') AND tree.path_len = 2  THEN
                    tree.name
              END
           ) IGNORE NULLS OVER (
              PARTITION BY tree.owner, tree.object_name, tree.object_type
              ORDER BY tree.line, tree.col, tree.path_len
           ) AS procedure_name,
           REPLACE(tree.name, ':', NULL) AS name, -- remove intermediate statement marker
           tree.path_len,
           tree.type,
           tree.usage,
           refs.owner AS ref_owner,
           refs.object_type AS ref_object_type,
           refs.object_name AS ref_object_name,
           (
              -- this correlated subquery will be evaluated only,
              -- if the column TEXT is selected
              SELECT regexp_replace(src.text, chr(10)||'+$', null) -- remove trailing new line character
                FROM sys.all_source src
               WHERE src.owner = tree.owner
                 AND src.type = tree.object_type
                 AND src.name = tree.object_name
                 AND src.line = tree.line
           ) AS text,
           CASE
              WHEN tree.name_path LIKE '%:%' AND tree.usage != 'EXECUTE' THEN
                 -- ensure that this is really a child of a statement
                 last_value (
                    CASE
                       WHEN tree.usage = 'EXECUTE' THEN
                          tree.type
                    END
                 ) IGNORE NULLS OVER (
                    PARTITION BY tree.owner, tree.object_name, tree.object_type
                    ORDER BY tree.line, tree.col, tree.path_len
                 )
           END AS parent_statement_type,
           CASE
              WHEN tree.name_path LIKE '%:%' AND tree.usage != 'EXECUTE' THEN
                 -- ensure that this is really a child of a statement
                 last_value (
                    CASE
                       WHEN tree.usage = 'EXECUTE' THEN
                          tree.path_len
                    END
                 ) IGNORE NULLS OVER (
                    PARTITION BY tree.owner, tree.object_name, tree.object_type
                    ORDER BY tree.line, tree.col, tree.path_len
                 )
           END AS parent_statement_path_len,
           tree.signature,
           tree.usage_id,
           tree.usage_context_id
      FROM tree
      LEFT JOIN sys.all_identifiers refs
        ON refs.signature = tree.signature
           AND refs.usage = 'DECLARATION'
   )
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(line,'FM0000009') || ':' || to_char(col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       owner AS "Owner",
       object_type AS "Object type",
       object_name AS "Object name",
       parent_statement_type AS "Statement type",
       name AS "Function name",
       line AS "Line",
       col AS "Col",
       text AS "Text"
  FROM plscope_identifiers
 WHERE parent_statement_type IN ('SELECT', 'INSERT', 'UPDATE', 'DETETE', 'MERGE')
   AND type = 'FUNCTION' 
   AND usage = 'CALL'
   -- ensure function call is part of the parent statement
   AND (parent_statement_path_len >= path_len -2)
   -- do not report function calls from standard package such as USER, REPLACE, SUBSTR, etc.
   AND NOT (ref_owner = 'SYS' AND ref_object_type = 'PACKAGE' AND ref_object_name = 'STANDARD')
 ORDER BY owner, object_type, object_name, line, col]]></sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="27d1dbe9-015d-1000-8001-c0a801060752" type="" style="Table" enable="true">
		<name><![CDATA[CRUD Operations]]></name>
		<description><![CDATA[Reports static usages of tables/views/synonyms within packages, procedures, functions, triggers and types. Reports number of SELECT, INSERT, UPDATE, DELETE, MERGE, REFERENCE usages per PL/SQL unit ]]></description>
		<tooltip><![CDATA[Number of select, insert, update, delete, merge, reference usages per PL/SQL unit.]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[WITH
   dep AS (
      SELECT owner      AS owner,
             'TABLE'    AS type,
             table_name AS name,
             NULL AS referenced_owner,
             NULL AS referenced_type,
             NULL AS referenced_name
        FROM sys.all_tables
      UNION ALL
      SELECT owner,
             type,
             name,
             referenced_owner,
             referenced_type,
             referenced_name
        FROM sys.all_dependencies
       WHERE type IN ('VIEW', 'MATERIALIZED VIEW', 'SYNONYM')
   ),
   dep_graph AS (
      SELECT DISTINCT
             owner,
             type                          AS object_type,
             name                          AS object_name,
             connect_by_root(owner)        AS ref_owner,
             connect_by_root(type)         AS ref_object_type,
             connect_by_root(name)         AS ref_object_name,
             sys_connect_by_path(type,'/') AS ref_object_type_path,
             level                         AS path_len
        FROM dep
      CONNECT BY  PRIOR dep.owner = dep.referenced_owner
              AND PRIOR dep.type  = dep.referenced_type
              AND PRIOR dep.name  = dep.referenced_name
   ),
   base_ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
        FROM dba_identifiers
      UNION ALL
      SELECT owner,
             ':' || NVL(sql_id, type) AS name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' AS usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id,
             origin_con_id
       FROM dba_statements
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             coalesce(
                least(
                   usage_context_id,
                   max(usage_id) over (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY usage_id
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
                ),
                0
             ) AS usage_context_id, -- fix broken hierarchies
             origin_con_id
        FROM base_ids
       WHERE owner LIKE nvl(:OBJECT_OWNER, USER)
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id,
              ids.origin_con_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   ),
   plscope_identifiers AS (
     SELECT tree.owner,
            tree.object_type,
            tree.object_name,
            tree.line,
            tree.col,
            last_value (
               CASE
                  WHEN tree.type in ('PROCEDURE', 'FUNCTION') AND tree.path_len = 2  THEN
                     tree.name
               END
            ) IGNORE NULLS OVER (
               PARTITION BY tree.owner, tree.object_name, tree.object_type
               ORDER BY tree.line, tree.col, tree.path_len
            ) AS procedure_name,
            REPLACE(tree.name, ':', NULL) AS name, -- remove intermediate statement marker
            REPLACE(tree.name_path, ':', NULL) AS name_path, -- remove intermediate statement marker
            tree.path_len,
            tree.type,
            tree.usage,
            refs.owner AS ref_owner,
            refs.object_type AS ref_object_type,
            refs.object_name AS ref_object_name,
            (
               -- this correlated subquery will be evaluated only,
               -- if the column TEXT is selected
               SELECT regexp_replace(src.text, chr(10)||'+$', null) -- remove trailing new line character
                 FROM dba_source src
                WHERE src.owner = tree.owner
                  AND src.type = tree.object_type
                  AND src.name = tree.object_name
                  AND src.line = tree.line
            ) AS text,
            CASE
               WHEN tree.name_path LIKE '%:%' AND tree.usage != 'EXECUTE' THEN
                  -- ensure that this is really a child of a statement
                  last_value (
                     CASE
                        WHEN tree.usage = 'EXECUTE' THEN
                           tree.signature
                     END
                  ) IGNORE NULLS OVER (
                     PARTITION BY tree.owner, tree.object_name, tree.object_type
                     ORDER BY tree.line, tree.col, tree.path_len
                  )
            END AS parent_statement_signature,
            tree.signature,
            tree.usage_id,
            tree.usage_context_id
       FROM tree
       LEFT JOIN dba_identifiers refs
         ON refs.signature = tree.signature
            AND refs.usage = 'DECLARATION'
   ),
   tab_usage AS (
      SELECT ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             CASE
                WHEN refs.type IS NOT NULL THEN
                   refs.type
                ELSE
                   ids.usage
             END AS operation,
             dep_graph.ref_owner,
             dep_graph.ref_object_type,
             dep_graph.ref_object_name,
             CASE
                WHEN dep_graph.path_len = 1 THEN
                   'YES'
                ELSE
                   'NO'
             END AS direct_dependency,
             dep_graph.ref_object_type_path,
             LEAD(dep_graph.ref_object_type_path) OVER (
                ORDER BY ids.owner, ids.object_type, ids.object_name, ids.line, ids.col, dep_graph.path_len
             ) AS next_ref_object_type_path,
             ids.text
        FROM plscope_identifiers ids
        JOIN dep_graph
          ON dep_graph.owner           = ids.ref_owner
             AND dep_graph.object_type = ids.ref_object_type
             AND dep_graph.object_name = ids.ref_object_name
        LEFT JOIN sys.all_statements refs
          ON refs.signature = parent_statement_signature
       WHERE ids.type IN ('VIEW', 'TABLE', 'SYNONYM')
   ),
   plscope_tab_usage AS (
      SELECT owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             direct_dependency,
             text
        FROM tab_usage
       WHERE (ref_object_type != 'SYNONYM' OR next_ref_object_type_path IN ('/VIEW/SYNONYM','/TABLE/SYNONYM'))
   )
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(min(line),'FM0000009') || ':' || to_char(1,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       owner AS "Owner",
       object_type AS "Object type",
       object_name AS "Object name",
       procedure_name AS "Procedure name",
       ref_owner AS "Ref Owner", 
       ref_object_type "Ref object type", 
       ref_object_name "Ref object name", 
       SUM(CASE WHEN operation = 'SELECT' THEN 1 ELSE 0 END) AS "Select",
       SUM(CASE WHEN operation = 'INSERT' THEN 1 ELSE 0 END) AS "Insert",
       SUM(CASE WHEN operation = 'UPDATE' THEN 1 ELSE 0 END) AS "Update",
       SUM(CASE WHEN operation = 'DELETE' THEN 1 ELSE 0 END) AS "Delete",
       SUM(CASE WHEN operation = 'MERGE' THEN 1 ELSE 0 END) AS "Merge",
       SUM(CASE WHEN operation = 'REFERENCE' THEN 1 ELSE 0 END) AS "Reference"      
  FROM plscope_tab_usage
 WHERE operation in ('SELECT','INSERT','UPDATE','DELETE','MERGE','REFERENCE')
   AND direct_dependency = 'YES'
 GROUP by owner, object_type, object_name, procedure_name, ref_owner, ref_object_type, ref_object_name
 ORDER by owner, object_type, object_name, procedure_name, ref_owner, ref_object_type, ref_object_name]]></sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="2e3cb6a6-015d-1000-8001-c0a801126c36" type="" style="Table" enable="true">
		<name><![CDATA[Unused Local Identifiers]]></name>
		<description><![CDATA[Reports locally declared identifiers in within packages, procedures, functions, triggers and types which are not referenced.]]></description>
		<tooltip><![CDATA[Reports unreferenced locally defined identifiers]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="12.2">
			<sql><![CDATA[WITH
   base_ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
      UNION ALL
      SELECT owner,
             ':' || NVL(sql_id, type) AS name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' AS usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
       FROM sys.all_statements
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             coalesce(
                least(
                   usage_context_id,
                   max(usage_id) over (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY usage_id
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
                ),
                0
             ) AS usage_context_id -- fix broken hierarchies
        FROM base_ids
       WHERE owner LIKE nvl(:OBJECT_OWNER, USER)
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   ),
   plscope_identifiers AS (
       SELECT tree.owner,
              tree.object_type,
              tree.object_name,
              tree.line,
              tree.col,
              last_value (
                 CASE
                    WHEN tree.type in ('PROCEDURE', 'FUNCTION') AND tree.path_len = 2  THEN
                       tree.name
                 END
              ) IGNORE NULLS OVER (
                 PARTITION BY tree.owner, tree.object_name, tree.object_type
                 ORDER BY tree.line, tree.col, tree.path_len
              ) AS procedure_name,
              REPLACE(tree.name, ':', NULL) AS name, -- remove intermediate statement marker
              REPLACE(tree.name_path, ':', NULL) AS name_path, -- remove intermediate statement marker
              tree.path_len,
              tree.type,
              tree.usage,
              refs.owner AS ref_owner,
              refs.object_type AS ref_object_type,
              refs.object_name AS ref_object_name,
              (
                 -- this correlated subquery will be evaluated only,
                 -- if the column TEXT is selected
                 SELECT regexp_replace(src.text, chr(10)||'+$', null) -- remove trailing new line character
                   FROM sys.all_source src
                  WHERE src.owner = tree.owner
                    AND src.type = tree.object_type
                    AND src.name = tree.object_name
                    AND src.line = tree.line
              ) AS text,
              CASE 
                 WHEN tree.object_type IN ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
                    AND tree.usage = 'DECLARATION'
                    AND tree.type NOT IN ('LABEL')
                 THEN
                    CASE
                       WHEN 
                          count(
                             CASE 
                                WHEN tree.usage NOT IN ('DECLARATION', 'ASSIGNMENT') 
                                   OR (tree.type IN ('FORMAL OUT', 'FORMAL IN OUT')
                                       AND tree.usage = 'ASSIGNMENT')
                                THEN 
                                   1 
                             END
                          ) OVER (
                             PARTITION BY tree.owner, tree.object_name, tree.object_type, tree.signature
                          ) = 0
                       THEN
                          'NO'
                       ELSE
                          'YES'
                    END
              END AS is_used, -- wrong result, if used in statements which do not register usage, such as a variable for dynamic_sql_stmt in EXECUTE IMMEDIATE. Bug?
              tree.signature,
              tree.usage_id,
              tree.usage_context_id
         FROM tree
         LEFT JOIN sys.all_identifiers refs
           ON refs.signature = tree.signature
              AND refs.usage = 'DECLARATION'
   )
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(line,'FM0000009') || ':' || to_char(col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       owner AS "Owner",
       object_type AS "Object type",
       object_name AS "Object name",
       procedure_name AS "Procedure name",
       type AS "Type",
       name AS "Name",
       line AS "Line",
       col AS "Col",
       text AS "Text" 
  FROM plscope_identifiers
 WHERE usage = 'DECLARATION'
   AND is_used = 'NO'
 ORDER BY owner, object_type, object_name, line, col]]></sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
					null										</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="9f38924a-015d-1000-8001-c0a80112c4cd" type="" style="Table" enable="true">
		<name><![CDATA[PL/SQL Naming Conventions]]></name>
		<description><![CDATA[Check PL/SQL identifiers based on the Trivadis PL/SQL & SQL Coding Guidelines V3.2]]></description>
		<tooltip><![CDATA[Reports PL/SQL identifiers violationg naming conventions]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query minversion="11.1">
			<sql><![CDATA[WITH
   ids AS (
      SELECT owner,
             name,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
       WHERE owner LIKE nvl(:OBJECT_OWNER, USER)
   ),   
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              level as path_len,
              ids.type,
              sys_connect_by_path(ids.type, '/') AS type_path,
              ids.usage,
              ids.usage_id,
              ids.usage_context_id,
              prior ids.type AS parent_type,
              prior ids.usage AS parent_usage,
              prior ids.line AS parent_line,
              prior ids.col AS parent_col,
              prior ids.name AS parent_name
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   ),
   prepared AS (
      SELECT tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                CASE
                   WHEN tree.type in ('PROCEDURE', 'FUNCTION') AND tree.path_len = 2 THEN
                      tree.name
                END
             ) IGNORE NULLS OVER (
                PARTITION BY tree.owner, tree.object_name, tree.object_type
                ORDER BY tree.line, tree.col, tree.path_len
             ) AS procedure_name,
             (
                -- this correlated subquery will be evaluated only,
                -- if the column TEXT is selected
                SELECT regexp_replace(src.text, chr(10)||'+$', null) -- remove trailing new line character
                  FROM sys.all_source src
                 WHERE src.owner = tree.owner
                   AND src.type = tree.object_type
                   AND src.name = tree.object_name
                   AND src.line = tree.line
             ) AS text,
             tree.usage,
             tree.type,
             tree.name,
             tree.line,
             tree.col,
             tree.type_path,
             tree.parent_usage,
             tree.parent_type,
             tree.parent_name,
             tree.parent_line,
             tree.parent_col
        FROM tree
       WHERE tree.object_type IN ('FUNCTION', 'PROCEDURE', 'TRIGGER', 'PACKAGE', 'PACKAGE BODY', 'TYPE', 'TYPE BODY')
   ),
   checked AS (
      SELECT owner,
             object_type,
             object_name,
             procedure_name,
             CASE 
                WHEN usage = 'REFERENCE' THEN
                   parent_usage 
                ELSE
                   usage
             END AS usage,
             CASE 
                WHEN usage = 'REFERENCE' THEN
                   parent_type 
                ELSE
                   type
             END AS type,
             CASE 
                WHEN usage = 'REFERENCE' THEN
                   parent_name 
                ELSE
                   name
             END AS name,
             CASE
                -- global variables (all types)
                WHEN     parent_usage = 'DECLARATION'
                     AND parent_type = 'VARIABLE'
                     AND usage = 'REFERENCE'
                     AND regexp_like(type_path, '/PACKAGE/VARIABLE/[A-Z0-9_ ]*$')
                THEN
                   CASE 
                      WHEN regexp_like(parent_name, nvl(:GLOBAL_VARIABLE_REGEX, '^g_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Global variable does not match regex "' || nvl(:GLOBAL_VARIABLE_REGEX, '^g_.*') || '".'
                   END 
                -- local record variables
                WHEN     parent_usage = 'DECLARATION'
                     AND parent_type = 'VARIABLE'
                     AND usage = 'REFERENCE'
                     AND (type = 'RECORD' OR regexp_like(text, '.*%\s*rowtype.*', 'i'))
                     AND object_type != 'TYPE'
                     AND NOT regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                THEN
                   CASE
                      WHEN regexp_like(parent_name, nvl(:LOCAL_RECORD_VARIABLE_REGEX, '^r_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Local record variable does not match regex "' || nvl(:LOCAL_RECORD_VARIABLE_REGEX, '^r_.*') || '".'
                   END
                -- local array/table variables
                WHEN     parent_usage = 'DECLARATION'
                     AND parent_type = 'VARIABLE'
                     AND usage = 'REFERENCE'
                     AND type IN ('ASSOCIATIVE ARRAY', 'VARRAY', 'INDEX TABLE', 'NESTED TABLE')
                     AND object_type != 'TYPE'
                     AND NOT regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                THEN
                   CASE
                      WHEN regexp_like(parent_name, nvl(:LOCAL_ARRAY_VARIABLE_REGEX, '^t_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Local array/table variable does not match regex "' || nvl(:LOCAL_ARRAY_VARIABLE_REGEX, '^t_.*') || '".'
                   END
                -- local object variables
                WHEN     parent_usage = 'DECLARATION'
                     AND parent_type = 'VARIABLE'
                     AND usage = 'REFERENCE'
                     AND type = 'OBJECT'
                     AND object_type != 'TYPE'
                     AND NOT regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                THEN
                   CASE
                      WHEN regexp_like(parent_name, nvl(:LOCAL_OBJECT_VARIABLE_REGEX, '^o_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Local object variable does not match regex "' || nvl(:LOCAL_OBJECT_VARIABLE_REGEX, '^o_.*') || '".'
                   END
                -- local variables for other types
                WHEN     parent_usage = 'DECLARATION'
                     AND parent_type = 'VARIABLE'
                     AND usage = 'REFERENCE'
                     AND object_type != 'TYPE'
                     AND NOT regexp_like(type_path, '/(RECORD|OBJECT)/VARIABLE/[A-Z0-9_ ]*$')
                THEN
                   CASE
                      WHEN regexp_like(parent_name, nvl(:LOCAL_VARIABLE_REGEX, '^l_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Local variable does not match regex "' || nvl(:LOCAL_VARIABLE_REGEX, '^l_.*') || '".'
                   END
                -- cursors
                WHEN     usage = 'DECLARATION'
                     AND type = 'CURSOR'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:CURSOR_REGEX, '^c_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Cursor does not match regex "' || nvl(:CURSOR_REGEX, '^c_.*') || '".'
                   END
                -- cursor parameters
                WHEN     parent_usage = 'DECLARATION'
                     AND parent_type = 'CURSOR'
                     AND usage = 'DECLARATION'
                     AND type LIKE 'FORMAL%'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:CURSOR_PARAMETER_REGEX, '^p_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Cursor parameter does not match regex "' || nvl(:CURSOR_PARAMETER_REGEX, '^p_.*') || '".'
                   END
                -- IN parameters
                WHEN     usage = 'DECLARATION'
                     AND type = 'FORMAL IN'
                THEN
                   CASE
                      WHEN    regexp_like(name, nvl(:IN_PARAMETER_REGEX, '^in_.*'), 'i')   
                           OR (object_type IN ('TYPE', 'TYPE BODY') AND name = 'SELF')
                      THEN
                         'OK'
                      ELSE
                         'IN parameter does not match regex "' || nvl(:IN_PARAMETER_REGEX, '^in_.*') || '".'
                   END
                -- OUT parameters
                WHEN     usage = 'DECLARATION'
                     AND type = 'FORMAL OUT'
                THEN
                   CASE
                      WHEN    regexp_like(name, nvl(:OUT_PARAMETER_REGEX, '^out_.*'), 'i')   
                           OR (object_type IN ('TYPE', 'TYPE BODY') AND name = 'SELF')
                      THEN
                         'OK'
                      ELSE
                         'OUT parameter does not match regex "' || nvl(:OUT_PARAMETER_REGEX, '^out_.*') || '".'
                   END
                -- IN OUT parameters
                WHEN     usage = 'DECLARATION'
                     AND type = 'FORMAL IN OUT'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:IN_OUT_PARAMETER_REGEX, '^io_.*'), 'i')   
                           OR (object_type IN ('TYPE', 'TYPE BODY') AND name = 'SELF')
                      THEN
                         'OK'
                      ELSE
                         'IN OUT parameter does not match regex "' || nvl(:IN_OUT_PARAMETER_REGEX, '^io_.*') || '".'
                   END
                -- records
                WHEN     usage = 'DECLARATION'
                     AND type = 'RECORD'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:RECORD_REGEX, '^r_.*_type$'), 'i') THEN
                         'OK'
                      ELSE
                         'Record does not match regex "' || nvl(:RECORD_REGEX, '^r_.*_type$') || '".'
                   END
                -- arrays/tables
                WHEN     usage = 'DECLARATION'
                     AND type IN ('ASSOCIATIVE ARRAY', 'VARRAY', 'INDEX TABLE', 'NESTED TABLE')
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:ARRAY_REGEX, '^t_.*_type$'), 'i') THEN
                         'OK'
                      ELSE
                         'Array/table does not match regex "' || nvl(:ARRAY_REGEX, '^t_.*_type$') || '".'
                   END
                -- exceptions
                WHEN     usage = 'DECLARATION'
                     AND type = 'EXCEPTION'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:EXCEPTION_REGEX, '^e_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Exception does not match regex "' || nvl(:EXCEPTION_REGEX, '^e_.*') || '".'
                   END
                -- constants
                WHEN     usage = 'DECLARATION'
                     AND type = 'CONSTANT'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:CONSTANT_REGEX, '^co_.*'), 'i') THEN
                         'OK'
                      ELSE
                         'Constant does not match regex "' || nvl(:CONSTANT_REGEX, '^co_.*') || '".'
                   END
                -- subtypes
                WHEN     usage = 'DECLARATION'
                     AND type = 'SUBTYPE'
                THEN
                   CASE
                      WHEN regexp_like(name, nvl(:SUBTYPE_REGEX, '.*_type$'), 'i') THEN
                         'OK'
                      ELSE
                         'Subtype does not match regex "' || nvl(:SUBTYPE_REGEX, '.*_type$') || '".'
                   END
             END AS message,
             CASE 
                WHEN usage = 'REFERENCE' THEN
                   parent_line 
                ELSE
                   line
             END AS line,
             CASE 
                WHEN usage = 'REFERENCE' THEN
                   parent_col 
                ELSE
                   col
             END AS col,
             text
        FROM prepared
   )
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(line,'FM0000009') || ':' || to_char(col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       owner AS "Owner", 
       object_type AS "Object type", 
       object_name AS "Object name", 
       procedure_name AS "Procedure name",
       type AS "Type",
       name AS "Name",
       message AS "Message",
       line AS "Line",
       col AS "Col",
       text AS "Text"
  FROM checked
 WHERE message != 'OK'
 ORDER BY owner, object_type, object_name, line, col]]></sql>
			<binds>
				<bind id="OBJECT_OWNER">
					<prompt><![CDATA[Owner like]]></prompt>
					<tooltip><![CDATA[OBJECT_OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="GLOBAL_VARIABLE_REGEX">
					<prompt><![CDATA[Global variable regex]]></prompt>
					<tooltip><![CDATA[GLOBAL_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^g_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_RECORD_VARIABLE_REGEX">
					<prompt><![CDATA[Local record variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_RECORD_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^r_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_ARRAY_VARIABLE_REGEX">
					<prompt><![CDATA[Local array/table variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_ARRAY_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^t_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_OBJECT_VARIABLE_REGEX">
					<prompt><![CDATA[Local object variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_OBJECT_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^o_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="LOCAL_VARIABLE_REGEX">
					<prompt><![CDATA[Local variable regex]]></prompt>
					<tooltip><![CDATA[LOCAL_VARIABLE_REGEX]]></tooltip>
					<value><![CDATA[^l_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CURSOR_REGEX">
					<prompt><![CDATA[Cursor regex]]></prompt>
					<tooltip><![CDATA[CURSOR_REGEX]]></tooltip>
					<value><![CDATA[^c_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CURSOR_PARAMETER_REGEX">
					<prompt><![CDATA[Cursor parameter regex]]></prompt>
					<tooltip><![CDATA[CURSOR_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^p_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="IN_PARAMETER_REGEX">
					<prompt><![CDATA[IN parameter regex]]></prompt>
					<tooltip><![CDATA[IN_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^in_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="OUT_PARAMETER_REGEX">
					<prompt><![CDATA[OUT parameter regex]]></prompt>
					<tooltip><![CDATA[OUT_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^out_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="IN_OUT_PARAMETER_REGEX">
					<prompt><![CDATA[IN OUT_parameter regex]]></prompt>
					<tooltip><![CDATA[IN_OUT_PARAMETER_REGEX]]></tooltip>
					<value><![CDATA[^io_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="RECORD_REGEX">
					<prompt><![CDATA[Record regex]]></prompt>
					<tooltip><![CDATA[RECORD_REGEX]]></tooltip>
					<value><![CDATA[^r_.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="ARRAY_REGEX">
					<prompt><![CDATA[Array/table regex]]></prompt>
					<tooltip><![CDATA[ARRAY_REGEX]]></tooltip>
					<value><![CDATA[^t_.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="EXCEPTION_REGEX">
					<prompt><![CDATA[Exception regex]]></prompt>
					<tooltip><![CDATA[EXCEPTION_REGEX]]></tooltip>
					<value><![CDATA[^e_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CONSTANT_REGEX">
					<prompt><![CDATA[Constant regex]]></prompt>
					<tooltip><![CDATA[CONSTANT_REGEX]]></tooltip>
					<value><![CDATA[^co_.*]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SUBTYPE_REGEX">
					<prompt><![CDATA[Subtype regex]]></prompt>
					<tooltip><![CDATA[SUBTYPE_REGEX]]></tooltip>
					<value><![CDATA[.*_type$]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
</folder>
</displays>