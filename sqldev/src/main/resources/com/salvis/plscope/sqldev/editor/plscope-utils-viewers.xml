<?xml version="1.0" encoding="UTF-8"?>
<displays>
	<!-- based on -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_identifiers.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_statements.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_tab_usage.sql -->
	<!-- - https://github.com/PhilippSalvisberg/plscope-utils/blob/master/database/utils/view/plscope_col_usage.sql -->
	<!-- used sys.all_ instead of dba_ - SQL Developer uses dba_ views, if the the connected use has the privileges -->
	<!-- Use case sensitive result columns including spaces -->
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,SYNONYM,TABLE,TRIGGER,TYPE,VIEW,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-synonym,plscope-utils-table,plscope-utils-trigger,plscope-utils-type,plscope-utils-view">
		<name><![CDATA[Identifiers]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
WITH
   src AS (
      SELECT /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        FROM sys.all_source
       WHERE type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND name = :OBJECT_NAME 
   ),
   prep_ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
      UNION ALL
      SELECT owner,
             ':' || NVL(sql_id, type) AS name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' AS usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
       FROM sys.all_statements
   ),
   fids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM prep_ids
       WHERE (owner = :OBJECT_OWNER OR upper(replace(:OBJECT_TYPE,'plscope-utils-')) = 'SYNONYM')
         AND object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND object_name = :OBJECT_NAME
   ),
   base_ids AS (
      SELECT fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             CASE
                WHEN fk.usage_id IS NOT NULL OR fids.usage_context_id = 0 THEN
                   'YES'
                ELSE
                   'NO'
             END AS sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        FROM fids
        LEFT JOIN fids fk
          ON fk.owner = fids.owner
             AND fk.object_type = fids.object_type
             AND fk.object_name = fids.object_name
             AND fk.usage_id = fids.usage_context_id
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             CASE
                WHEN sane_fk = 'YES' THEN
                   usage_context_id
                ELSE
                   last_value(CASE WHEN sane_fk = 'YES' THEN usage_id END) IGNORE NULLS OVER (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY line, col
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
             END AS usage_context_id -- fix broken hierarchies
        FROM base_ids
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   )
 SELECT CASE
           WHEN tree.object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
              'SQLDEV:LINK:' || tree.owner || ':' || tree.object_type || ':' || tree.object_name || ':' ||
                 to_char(tree.line,'FM0000009') || ':' || to_char(tree.col,'FM0000009') || ':' || 'Source' ||
                 ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
           ELSE
              NULL
        END AS "Link",
        lpad(' ', 3 * (tree.path_len - 1)) || tree.usage AS "Usage",
        tree.type AS "Type",
        replace(tree.name, ':', NULL) AS "Name", -- remove intermediate statement marker
        CASE 
           WHEN tree.object_type IN ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
              AND tree.usage = 'DECLARATION'
              AND tree.type NOT IN ('LABEL')
           THEN
              CASE
                 WHEN 
                    count(
                       CASE 
                          WHEN tree.usage NOT IN ('DECLARATION', 'ASSIGNMENT') 
                             OR (tree.type IN ('FORMAL OUT', 'FORMAL IN OUT')
                                 AND tree.usage = 'ASSIGNMENT')
                          THEN 
                             1 
                       END
                    ) OVER (
                       PARTITION BY tree.owner, tree.object_name, tree.object_type, tree.signature
                    ) = 0
                 THEN
                    'NO'
                 ELSE
                    'YES'
              END
        END AS "Used?",
        tree.line AS "Line",
        tree.col AS "Col",
        regexp_replace(src.text, chr(10)||'+$', null) AS "Text" -- remove trailing new line character
   FROM tree
   LEFT JOIN src
     ON src.owner = tree.owner
        AND src.type = tree.object_type
        AND src.name = tree.object_name
        AND src.line = tree.line
  ORDER BY length(tree.object_type), tree.line, tree.col, tree.path_len
				]]></sql>
			</query>
			<query minversion="11.1">
				<sql><![CDATA[
WITH
   src AS (
      SELECT /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        FROM sys.all_source
       WHERE type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND name = :OBJECT_NAME 
   ),
   fids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
       WHERE (owner = :OBJECT_OWNER OR upper(replace(:OBJECT_TYPE,'plscope-utils-')) = 'SYNONYM')
         AND object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND object_name = :OBJECT_NAME
   ),
   base_ids AS (
      SELECT fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             CASE
                WHEN fk.usage_id IS NOT NULL OR fids.usage_context_id = 0 THEN
                   'YES'
                ELSE
                   'NO'
             END AS sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        FROM fids
        LEFT JOIN fids fk
          ON fk.owner = fids.owner
             AND fk.object_type = fids.object_type
             AND fk.object_name = fids.object_name
             AND fk.usage_id = fids.usage_context_id
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             CASE
                WHEN sane_fk = 'YES' THEN
                   usage_context_id
                ELSE
                   last_value(CASE WHEN sane_fk = 'YES' THEN usage_id END) IGNORE NULLS OVER (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY line, col
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
             END AS usage_context_id -- fix broken hierarchies
        FROM base_ids
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   )
 SELECT CASE
           WHEN tree.object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
              'SQLDEV:LINK:' || tree.owner || ':' || tree.object_type || ':' || tree.object_name || ':' ||
                 to_char(tree.line,'FM0000009') || ':' || to_char(tree.col,'FM0000009') || ':' || 'Source' || 
                 ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
           ELSE
              NULL
        END AS "Link",
        lpad(' ', 3 * (tree.path_len - 1)) || tree.usage AS "Usage",
        tree.type AS "Type",
        replace(tree.name, ':', NULL) AS "Name", -- remove intermediate statement marker
        CASE 
           WHEN tree.object_type IN ('PACKAGE BODY', 'PROCEDURE', 'FUNCTION', 'TYPE BODY')
              AND tree.usage = 'DECLARATION'
              AND tree.type NOT IN ('LABEL')
           THEN
              CASE
                 WHEN 
                    count(
                       CASE 
                          WHEN tree.usage NOT IN ('DECLARATION', 'ASSIGNMENT') 
                             OR (tree.type IN ('FORMAL OUT', 'FORMAL IN OUT')
                                 AND tree.usage = 'ASSIGNMENT')
                          THEN 
                             1 
                       END
                    ) OVER (
                       PARTITION BY tree.owner, tree.object_name, tree.object_type, tree.signature
                    ) = 0
                 THEN
                    'NO'
                 ELSE
                    'YES'
              END
        END AS "Used?",
        tree.line AS "Line",
        tree.col AS "Col",
        regexp_replace(src.text, chr(10)||'+$', null) AS "Text" -- remove trailing new line character
   FROM tree
   LEFT JOIN src
     ON src.owner = tree.owner
        AND src.type = tree.object_type
        AND src.name = tree.object_name
        AND src.line = tree.line
  ORDER BY length(tree.object_type), tree.line, tree.col, tree.path_len
				]]></sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Statements]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(line,'FM0000009') || ':' || to_char(col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       type AS "Type",
       line AS "Line", 
       col AS "Col", 
       sql_id AS "SQL_ID",
       CASE 
          WHEN (count(sql_id) OVER (PARTITION BY sql_id)) > 1 THEN 
             'YES'
          ELSE 
             'NO' 
       END AS "Duplicate?",
       has_hint AS "Has hint?", 
       has_into_bulk AS "Has bulk into?", 
       has_into_returning AS "Has returning into?", 
       has_into_record AS "Has into record?", 
       has_current_of AS "Has current of?", 
       has_for_update AS "Has for update?",
       has_in_binds AS "Has binds?", 
       full_text AS "Text"
  FROM sys.all_statements
 WHERE owner       = :OBJECT_OWNER
  AND object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
  AND object_name = :OBJECT_NAME
 ORDER BY length(object_type), line, col
				]]></sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Uses]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="11.1">
				<sql><![CDATA[
WITH
   src AS (
      SELECT /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        FROM sys.all_source
       WHERE type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND name = :OBJECT_NAME 
   ),
   ids AS (
      SELECT /*+ materialize */
             owner,
             object_type,
             object_name,
             signature,
             usage,
             type,
             name,
             line,
             col
        FROM sys.all_identifiers
       WHERE usage IN ('CALL','REFERENCE')
         AND (owner = :OBJECT_OWNER OR upper(replace(:OBJECT_TYPE,'plscope-utils-')) = 'SYNONYM')
         AND object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')
         AND object_name = :OBJECT_NAME
   )
SELECT CASE
          WHEN ids.object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || ids.owner || ':' || ids.object_type || ':' || ids.object_name || ':' ||
                to_char(ids.line,'FM0000009') || ':' || to_char(ids.col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       CASE
          WHEN refs.object_type = 'SYNONYM' THEN
             s.table_owner
          ELSE
             refs.owner
       END AS "Owner",
       CASE
          WHEN refs.object_type = 'SYNONYM' THEN
             o.object_type
          ELSE
             refs.object_type
       END AS "Object type",
       CASE
          WHEN refs.object_type = 'SYNONYM' THEN
             s.table_name
          ELSE
             refs.object_name
       END AS "Object name",
       ids.usage AS "Usage",
       ids.type AS "Type",
       ids.name AS "Name",
       ids.line AS "Line",
       ids.col aS "Col",
       regexp_replace(src.text, chr(10)||'+$', null) AS "Text" -- remove trailing new line character
  from ids
  JOIN sys.all_identifiers refs
    ON ids.signature = refs.signature
  LEFT JOIN src
     ON src.owner = ids.owner
        AND src.type = ids.object_type
        AND src.name = ids.object_name
        AND src.line = ids.line
  LEFT JOIN sys.all_synonyms s
    ON s.owner = refs.owner
       AND s.synonym_name = refs.object_name
  LEFT JOIN sys.all_objects o
    ON o.owner = s.table_owner
       AND o.object_name = s.table_name
 WHERE refs.usage = 'DECLARATION'
   AND NOT (
              refs.owner       = :OBJECT_OWNER
          AND refs.object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
          AND refs.object_name = :OBJECT_NAME
       )
   AND NOT (
              refs.owner = 'SYS'
          AND refs.object_type = 'PACKAGE'
          AND refs.object_name = 'STANDARD'
       )
 ORDER BY ids.owner, ids.object_type, ids.object_name, ids.line, ids.col
				]]></sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,SYNONYM,TABLE,TRIGGER,TYPE,VIEW,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-synonym,plscope-utils-table,plscope-utils-trigger,plscope-utils-type,plscope-utils-view">
		<name><![CDATA[Used by]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="11.1">
				<sql><![CDATA[
WITH
   src AS (
      SELECT /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        FROM sys.all_source
       WHERE type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND name = :OBJECT_NAME 
   ),
   refs AS (
      SELECT /*+materialize */ 
             signature
        FROM sys.all_identifiers refs
       WHERE usage = 'DECLARATION'
         AND (owner = :OBJECT_OWNER OR upper(replace(:OBJECT_TYPE,'plscope-utils-')) = 'SYNONYM')
         AND object_type = upper(replace(:OBJECT_TYPE,'plscope-utils-')) 
         AND object_name = :OBJECT_NAME
   )
SELECT CASE
          WHEN ids.object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || ids.owner || ':' || ids.object_type || ':' || ids.object_name || ':' ||
                to_char(ids.line,'FM0000009') || ':' || to_char(ids.col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       ids.owner AS "Owner",
       ids.object_type AS "Object type",
       ids.object_name AS "Object name",
       ids.usage AS "Usage",
       ids.type AS "Type",
       ids.name AS "Name",
       ids.line AS "Line",
       ids.col aS "Col",
       regexp_replace(src.text, chr(10)||'+$', null) AS "Text" -- remove trailing new line character
  FROM refs
  JOIN sys.all_identifiers ids
    ON ids.signature = refs.signature
  LEFT JOIN src
     ON src.owner = ids.owner
        AND src.type = ids.object_type
        AND src.name = ids.object_name
        AND src.line = ids.line
 WHERE NOT (
              ids.owner       = :OBJECT_OWNER
          AND ids.object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
          AND ids.object_name = :OBJECT_NAME
       )   
 ORDER BY ids.owner, ids.object_type, ids.object_name, ids.line, ids.col
				]]></sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Table Usages]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
WITH
   src AS (
      SELECT /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        FROM sys.all_source
       WHERE type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND name = :OBJECT_NAME 
   ),
   prep_ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
      UNION ALL
      SELECT owner,
             ':' || NVL(sql_id, type) AS name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' AS usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
       FROM sys.all_statements
   ),
   fids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM prep_ids
       WHERE owner       = :OBJECT_OWNER
         AND object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND object_name = :OBJECT_NAME
   ),
   base_ids AS (
      SELECT fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             CASE
                WHEN fk.usage_id IS NOT NULL OR fids.usage_context_id = 0 THEN
                   'YES'
                ELSE
                   'NO'
             END AS sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        FROM fids
        LEFT JOIN fids fk
          ON fk.owner = fids.owner
             AND fk.object_type = fids.object_type
             AND fk.object_name = fids.object_name
             AND fk.usage_id = fids.usage_context_id
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             CASE
                WHEN sane_fk = 'YES' THEN
                   usage_context_id
                ELSE
                   last_value(CASE WHEN sane_fk = 'YES' THEN usage_id END) IGNORE NULLS OVER (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY line, col
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
             END AS usage_context_id -- fix broken hierarchies
        FROM base_ids
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   ), 
   plscope_identifiers AS (
      SELECT /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                CASE
                   WHEN tree.type in ('PROCEDURE', 'FUNCTION') AND tree.path_len = 2  THEN
                      tree.name
                END
             ) IGNORE NULLS OVER (
                PARTITION BY tree.owner, tree.object_name, tree.object_type
                ORDER BY tree.line, tree.col, tree.path_len
             ) AS procedure_name,
             tree.line,
             tree.col,
             REPLACE(tree.name, ':', NULL) AS name, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner AS ref_owner,
             refs.object_type AS ref_object_type,
             refs.object_name AS ref_object_name,
             regexp_replace(src.text, chr(10)||'+$', null) AS text, -- remove trailing new line character
             CASE
                WHEN tree.name_path LIKE '%:%' AND tree.usage != 'EXECUTE' THEN
                   -- ensure that this is really a child of a statement
                   last_value (
                      CASE
                         WHEN tree.usage = 'EXECUTE' THEN
                            tree.signature
                      END
                   ) IGNORE NULLS OVER (
                      PARTITION BY tree.owner, tree.object_name, tree.object_type
                      ORDER BY tree.line, tree.col, tree.path_len
                   )
             END AS parent_statement_signature,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        FROM tree
        LEFT JOIN sys.all_identifiers refs
          ON refs.signature = tree.signature
             AND refs.usage = 'DECLARATION'
        LEFT JOIN src
          ON src.owner = tree.owner
              AND src.type = tree.object_type
              AND src.name = tree.object_name
              AND src.line = tree.line
   ),
   dep AS (
      SELECT owner      AS owner,
             'TABLE'    AS type,
             table_name AS name,
             NULL AS referenced_owner,
             NULL AS referenced_type,
             NULL AS referenced_name
        FROM sys.all_tables
      UNION ALL
      SELECT owner,
             type,
             name,
             referenced_owner,
             referenced_type,
             referenced_name
        FROM sys.all_dependencies
       WHERE type IN ('VIEW', 'MATERIALIZED VIEW', 'SYNONYM')
   ),
   dep_graph AS (
      SELECT DISTINCT
             owner,
             type                          AS object_type,
             name                          AS object_name,
             connect_by_root(owner)        AS ref_owner,
             connect_by_root(type)         AS ref_object_type,
             connect_by_root(name)         AS ref_object_name,
             sys_connect_by_path(type,'/') AS ref_object_type_path,
             level                         AS path_len
        FROM dep
      CONNECT BY  PRIOR dep.owner = dep.referenced_owner
              AND PRIOR dep.type  = dep.referenced_type
              AND PRIOR dep.name  = dep.referenced_name
   ),
   plscope_tab_usage AS (
      SELECT /*+use_hash(ids) use_hash(dep_graph) use_hash(refs)*/
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             CASE
                WHEN refs.type IS NOT NULL THEN
                   refs.type
                ELSE
                   ids.usage
             END AS operation,
             dep_graph.ref_owner,
             dep_graph.ref_object_type,
             dep_graph.ref_object_name,
             CASE
                WHEN dep_graph.path_len = 1 THEN
                   'YES'
                ELSE
                   'NO'
             END AS direct_dependency,
             dep_graph.ref_object_type_path,
             LEAD(dep_graph.ref_object_type_path) OVER (
                ORDER BY ids.owner, ids.object_type, ids.object_name, ids.line, ids.col, dep_graph.path_len
             ) AS next_ref_object_type_path,
             ids.text,
             dep_graph.path_len
        FROM plscope_identifiers ids
        JOIN dep_graph
          ON dep_graph.owner           = ids.ref_owner
             AND dep_graph.object_type = ids.ref_object_type
             AND dep_graph.object_name = ids.ref_object_name
        LEFT JOIN sys.all_statements refs
          ON refs.signature = parent_statement_signature
       WHERE ids.type IN ('VIEW', 'TABLE', 'SYNONYM')
   )
SELECT CASE
          WHEN object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || owner || ':' || object_type || ':' || object_name || ':' ||
                to_char(line,'FM0000009') || ':' || to_char(col,'FM0000009') || ':' ||  'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       procedure_name AS "Procedure name",
       operation AS "Operation",
       direct_dependency AS "Direct dep?",
       ref_owner AS "Owner",
       ref_object_type AS "Object type",
       ref_object_name AS "Object name",
       line AS "Line",
       col AS "Col",
       text AS "Text"
  FROM plscope_tab_usage
 WHERE (ref_object_type != 'SYNONYM' OR next_ref_object_type_path IN ('/VIEW/SYNONYM','/TABLE/SYNONYM'))
       -- resolve synonyms as indirect dependencies only (do not resolve table usages in views)
   AND (path_len = 1 OR path_len = 2 AND ref_object_type_path LIKE '%SYNONYM')
 ORDER BY length(object_type), line, col, path_len
				]]></sql>
			</query>
		</queries>
	</display>
	<display type="editor" style="null" enable="true" connType="Oracle"
		objectType="FUNCTION,PACKAGE,PROCEDURE,TRIGGER,TYPE,plscope-utils-function,plscope-utils-package,plscope-utils-procedure,plscope-utils-trigger,plscope-utils-type">
		<name><![CDATA[Column Usages]]></name>
		<description><![CDATA[]]>
		</description>
		<tooltip><![CDATA[]]>
		</tooltip>
		<drillclass><![CDATA[null]]></drillclass>
		<queries>
			<query minversion="12.2">
				<sql><![CDATA[
WITH
   src AS (
      SELECT /*+ materialize */
             owner,
             type,
             name,
             line,
             text
        FROM sys.all_source
       WHERE type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND name = :OBJECT_NAME 
   ),
   prep_ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM sys.all_identifiers
      UNION ALL
      SELECT owner,
             ':' || NVL(sql_id, type) AS name,  -- intermediate statement marker colon
             signature,
             type,
             object_name,
             object_type,
             'EXECUTE' AS usage, -- new, artificial usage
             usage_id,
             line,
             col,
             usage_context_id
       FROM sys.all_statements
   ),
   fids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             usage_context_id
        FROM prep_ids
       WHERE owner       = :OBJECT_OWNER
         AND object_type IN (upper(replace(:OBJECT_TYPE,'plscope-utils-')), upper(replace(:OBJECT_TYPE,'plscope-utils-')) || ' BODY')  
         AND object_name = :OBJECT_NAME
   ),
   base_ids AS (
      SELECT fids.owner,
             fids.name,
             fids.signature,
             fids.type,
             fids.object_name,
             fids.object_type,
             fids.usage,
             fids.usage_id,
             CASE
                WHEN fk.usage_id IS NOT NULL OR fids.usage_context_id = 0 THEN
                   'YES'
                ELSE
                   'NO'
             END AS sane_fk,
             fids.line,
             fids.col,
             fids.usage_context_id
        FROM fids
        LEFT JOIN fids fk
          ON fk.owner = fids.owner
             AND fk.object_type = fids.object_type
             AND fk.object_name = fids.object_name
             AND fk.usage_id = fids.usage_context_id
   ),
   ids AS (
      SELECT owner,
             name,
             signature,
             type,
             object_name,
             object_type,
             usage,
             usage_id,
             line,
             col,
             CASE
                WHEN sane_fk = 'YES' THEN
                   usage_context_id
                ELSE
                   last_value(CASE WHEN sane_fk = 'YES' THEN usage_id END) IGNORE NULLS OVER (
                      PARTITION BY owner, object_name, object_type
                      ORDER BY line, col
                      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                   )
             END AS usage_context_id -- fix broken hierarchies
        FROM base_ids
   ),
   tree AS (
       SELECT ids.owner,
              ids.object_type,
              ids.object_name,
              ids.line,
              ids.col,
              ids.name,
              replace(sys_connect_by_path(ids.name, '|'),'|','/') AS name_path,
              level as path_len,
              ids.type,
              ids.usage,
              ids.signature,
              ids.usage_id,
              ids.usage_context_id
         FROM ids
        START WITH ids.usage_context_id = 0
      CONNECT BY  PRIOR ids.usage_id    = ids.usage_context_id
              AND PRIOR ids.owner       = ids.owner
              AND PRIOR ids.object_type = ids.object_type
              AND PRIOR ids.object_name = ids.object_name
   ), 
   plscope_identifiers AS (
      SELECT /*+use_hash(tree) use_hash(refs) */
             tree.owner,
             tree.object_type,
             tree.object_name,
             last_value (
                CASE
                   WHEN tree.type in ('PROCEDURE', 'FUNCTION') AND tree.path_len = 2  THEN
                      tree.name
                END
             ) IGNORE NULLS OVER (
                PARTITION BY tree.owner, tree.object_name, tree.object_type
                ORDER BY tree.line, tree.col, tree.path_len
             ) AS procedure_name,
             tree.line,
             tree.col,
             REPLACE(tree.name, ':', NULL) AS name, -- remove intermediate statement marker
             tree.path_len,
             tree.type,
             tree.usage,
             refs.owner AS ref_owner,
             refs.object_type AS ref_object_type,
             refs.object_name AS ref_object_name,
             CASE
                WHEN tree.name_path LIKE '%:%' AND tree.usage != 'EXECUTE' THEN
                   -- ensure that this is really a child of a statement
                   last_value (
                      CASE
                         WHEN tree.usage = 'EXECUTE' THEN
                            tree.signature
                      END
                   ) IGNORE NULLS OVER (
                      PARTITION BY tree.owner, tree.object_name, tree.object_type
                      ORDER BY tree.line, tree.col, tree.path_len
                   )
             END AS parent_statement_signature,
             tree.signature,
             tree.usage_id,
             tree.usage_context_id
        FROM tree
        LEFT JOIN sys.all_identifiers refs
          ON refs.signature = tree.signature
             AND refs.usage = 'DECLARATION'
   ),
   dep AS (
      SELECT owner      AS owner,
             'TABLE'    AS type,
             table_name AS name,
             NULL AS referenced_owner,
             NULL AS referenced_type,
             NULL AS referenced_name
        FROM sys.all_tables
      UNION ALL
      SELECT owner,
             type,
             name,
             referenced_owner,
             referenced_type,
             referenced_name
        FROM sys.all_dependencies
       WHERE type IN ('VIEW', 'MATERIALIZED VIEW', 'SYNONYM')
   ),
   dep_graph AS (
      SELECT DISTINCT
             owner,
             type                   AS object_type,
             name                   AS object_name,
             connect_by_root(owner) AS ref_owner,
             connect_by_root(type)  AS ref_object_type,
             connect_by_root(name)  AS ref_object_name,
             level                  AS path_len
        FROM dep
      CONNECT BY  PRIOR dep.owner = dep.referenced_owner
              AND PRIOR dep.type  = dep.referenced_type
              AND PRIOR dep.name  = dep.referenced_name
   ),
   plscope_tab_usage AS (
      SELECT /*+use_hash(ids) use_hash(dep_graph) use_hash(refs)*/
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             CASE
                WHEN refs.type IS NOT NULL THEN
                   refs.type
                ELSE
                   ids.usage
             END AS operation,
             ids.path_len,
             dep_graph.ref_owner,
             dep_graph.ref_object_type,
             dep_graph.ref_object_name,
             CASE
                WHEN dep_graph.path_len = 1 THEN
                   'YES'
                ELSE
                   'NO'
             END AS direct_dependency
        FROM plscope_identifiers ids
        LEFT JOIN sys.all_statements refs
          ON refs.signature = parent_statement_signature
        JOIN dep_graph
          ON dep_graph.owner           = ids.ref_owner
             AND dep_graph.object_type = ids.ref_object_type
             AND dep_graph.object_name = ids.ref_object_name
       WHERE ids.type IN ('VIEW', 'TABLE', 'MATERIALIZED VIEW', 'SYNONYM')
         AND NOT (ids.type = 'SYNONYM' AND refs.type IN ('PROCEDURE', 'FUNCTION'))
   ),
   scope_cols AS (
      SELECT /*+use_hash(ids) use_hash(refs) */
             ids.owner,
             ids.object_type,
             ids.object_name,
             ids.line,
             ids.col,
             ids.procedure_name,
             CASE 
                WHEN refs.type IS NOT NULL THEN
                   refs.type 
                ELSE
                   ids.usage
             END AS operation,
             ids.ref_owner,
             ids.ref_object_type,
             ids.ref_object_name,
             ids.name as column_name,
             ids.path_len
        FROM plscope_identifiers ids
        LEFT JOIN sys.all_statements refs
          ON refs.signature = parent_statement_signature
       WHERE ids.type = 'COLUMN'
         AND ids.usage != 'DECLARATION'
   ),
   missing_cols AS (
      SELECT /*+use_hash(t) use_hash(s) use_hash(o) use_hash(c) use_hash(tc) */
             t.owner,
             t.object_type,
             t.object_name,
             t.line,
             t.col,
             t.procedure_name,
             t.operation,
             coalesce(o.owner, t.ref_owner) AS ref_owner,
             coalesce(o.object_type, t.ref_object_type) AS ref_object_type,
             coalesce(o.object_name, t.ref_object_name) AS ref_object_name,
             tc.column_name,
             t.path_len
        FROM plscope_tab_usage t
        LEFT JOIN sys.all_synonyms s
          ON s.owner            = t.ref_owner
             AND s.synonym_name = t.ref_object_name
        LEFT JOIN sys.all_objects o
          ON o.owner            = s.table_owner
            AND o.object_name   = s.table_name
        LEFT JOIN scope_cols c
          ON t.owner                                        = c.owner
             AND t.object_type                              = c.object_type
             AND t.object_name                              = c.object_name
             AND t.procedure_name                           = c.procedure_name
             AND coalesce(o.owner, t.ref_owner)             = c.ref_owner
             AND coalesce(o.object_type, t.ref_object_type) = c.ref_object_type
             AND coalesce(o.object_name, t.ref_object_name) = c.ref_object_name
        JOIN sys.all_tab_columns tc
          ON tc.owner = t.owner
             AND tc.table_name = coalesce(o.object_name,t.ref_object_name)
       WHERE direct_dependency = 'YES'
         AND c.owner IS NULL
         AND t.operation IN ('INSERT', 'SELECT')
   ),
   base_cols AS (
      SELECT owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             path_len,
             'YES' AS direct_dependency
        FROM scope_cols
      UNION ALL
      SELECT owner,
             object_type,
             object_name,
             line,
             col,
             procedure_name,
             operation,
             ref_owner,
             ref_object_type,
             ref_object_name,
             column_name,
             path_len,
             'NO' AS direct_dependency
        FROM missing_cols
   )
SELECT CASE
          WHEN base_cols.object_type IN ('FUNCTION', 'PACKAGE', 'PACKAGE BODY', 'PROCEDURE', 'TRIGGER', 'TYPE', 'TYPE BODY') THEN
             'SQLDEV:LINK:' || base_cols.owner || ':' || base_cols.object_type || ':' || base_cols.object_name || ':' ||
                to_char(base_cols.line,'FM0000009') || ':' || to_char(base_cols.col,'FM0000009') || ':' || 'Source' ||
                ':oracle.dbtools.raptor.controls.grid.DefaultDrillLink'
          ELSE
             NULL
       END AS "Link",
       base_cols.procedure_name AS "Procedure name",
       base_cols.operation AS "Operation",
       base_cols.direct_dependency AS "Direct dep?",
       base_cols.ref_owner "Owner",
       base_cols.ref_object_type AS "Object type",
       base_cols.ref_object_name AS "Object name",
       base_cols.column_name AS "Column name",
       base_cols.line AS "Line",
       base_cols.col AS "Col",
       regexp_replace(src.text, chr(10)||'+$', null) AS "Text" -- remove trailing new line character
  FROM base_cols
  LEFT JOIN src
         ON src.owner = base_cols.owner
            AND src.type = base_cols.object_type
            AND src.name = base_cols.object_name
            AND src.line = base_cols.line
 ORDER BY length(base_cols.object_type), base_cols.line, base_cols.col, base_cols.path_len
				]]></sql>
			</query>
		</queries>
	</display>
</displays>
